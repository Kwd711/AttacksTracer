package malwaresimulator

import akka.actor.typed.{ActorRef, Behavior}
import akka.actor.typed.scaladsl.Behaviors
import malwaresimulator.engine.core.InetAddress

object MalwareSimulatorSupervisor {

  sealed trait Operation
  final case class ShowNet(replyTo: ActorRef[proto.WholeNetwork]) extends Operation
  final case class AddNode(replyTo: ActorRef[proto.Node], name: String, address: String) extends Operation
  final case class AddNetwork(replyTo: ActorRef[proto.Network], name: String, address: String, subnetMask: Int) extends Operation
  final case class MakeConnection(replyTo: ActorRef[proto.WholeNetwork], nodeId: Int, networkId: Int, address: String, subnetMask: Int) extends Operation

  final case class Network(id: Int, name: String, address: InetAddress, subnetMask: Int, nodes: List[Node]) extends Operation
  final case class Node(id: Int, name: String, address: InetAddress, applications: List[Application]) extends malwaresimulator.Network.NetworkCommand
  final case class Application(id: Int, name: String)

  sealed trait Reply
  final case class WholeNetwork(networks: List[Network] /*, isolatedNodes: List[Node]*/) extends Reply

  final case class ActorType[T](actorRef: ActorRef[T], t: String)

  def apply: Behaviors.Receive[Operation] = apply(Map.empty, 1)

  def apply(actors: Map[Int, ActorType[malwaresimulator.Network.NetworkCommand]], id: Int): Behaviors.Receive[Operation] = Behaviors.receive {
    case (context, ShowNet(replyTo)) =>
      println("Supervisor received ShowNet")
      val uuid = java.util.UUID.randomUUID().toString
      context.spawn(collectNetworkInfo(actors, replyTo), s"collectNetworkInfo-$uuid")
      Behaviors.same
    case (ctx, AddNode(replyTo, name, address)) =>
      val nodeRef = ctx.spawn(nodes.Node(id, name, InetAddress(address)), name)
      replyTo ! proto.Node(id, name, address, List.empty)
      apply(actors + (id -> ActorType(nodeRef, "Node")), id + 1)
    case (ctx, AddNetwork(replyTo, name, address, subnetMask)) =>
      val networkRef = ctx.spawn(malwaresimulator.Network(id, name, InetAddress(address), subnetMask), name)
      replyTo ! proto.Network(id, name, address, subnetMask)
      apply(actors + (id -> ActorType(networkRef, "Network")), id + 1)
    case (ctx, MakeConnection(replyTo, nodeId, networkId, address, subnetMask)) =>
      val nodeRef = actors(nodeId).actorRef
      val networkRef = actors(networkId).actorRef
      (nodeRef, networkRef) match {
        case (nodeRef: ActorRef[nodes.Node.NodeCommand], networkRef: ActorRef[malwaresimulator.Network.NetworkCommand]) =>
          networkRef ! malwaresimulator.Network.AddNode(nodeRef, InetAddress(address))
          nodeRef ! nodes.Node.MakeConnection(InetAddress(address), subnetMask, networkRef)
          val uuid = java.util.UUID.randomUUID().toString
          ctx.spawn(collectNetworkInfo(actors, replyTo), s"collectNetworkInfo-$uuid")
        case _ =>
          ()
      }
      Behaviors.same
  }

  def collectNetworkInfo(actors: Map[Int, ActorType[malwaresimulator.Network.NetworkCommand]], replyTo: ActorRef[proto.WholeNetwork]): Behavior[AnyRef] = {
    Behaviors.setup[AnyRef] { context =>
      var count = 0
      var list: Seq[proto.Network] = Seq.empty
      actors.foreach{ case (id, at) =>
        at.t match {
          case "Node" => ()
          case "Network" =>
            at.actorRef ! malwaresimulator.Network.ShowNetwork(context.self)
            count += 1
        }
      }

      def next(): Behavior[AnyRef] = {
        if (count > 0) {
          Behaviors.same
        } else {
          replyTo ! proto.WholeNetwork(list)
          Behaviors.stopped
        }
      }

      next()
      Behaviors.receiveMessage {
        case n: proto.Network =>
          list = list :+ n
          count -= 1
          next()
        case _ =>
          Behaviors.unhandled
      }
    }
  }
}
