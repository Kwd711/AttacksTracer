package malwaresimulator.engine

import akka.actor.typed.Behavior
import akka.actor.typed.scaladsl.Behaviors
import malwaresimulator.engine.core.{Datagram, InetAddress}
import malwaresimulator.nodes.Node.{ConnectionsList, MakeConnection, NodeCommand, ShowConnections}
import malwaresimulator.nodes.RoutingNode

import scala.collection.mutable.ListBuffer

object Firewall {
  trait FirewallCommand

  case class AddRule(newRule: FirewallRule) extends FirewallCommand

  def apply(id: Int, name: String, address: InetAddress): Behavior[FirewallCommand] = {
    new Firewall(id, name, address).receive()
  }
}

class Firewall(val id: Int, val name: String, val address: InetAddress) extends RoutingNode {
  import Firewall._

  var firewallRules: ListBuffer[FirewallRule] = ListBuffer.empty

  def receive(): Behavior[FirewallCommand] = {
    Behaviors.receive { (context, message) =>
      message match {
        case d: Datagram =>
          networkResponse(d)
          Behaviors.same
        case MakeConnection(address, netmask, net) =>
          makeConnection(address, netmask, net)
          Behaviors.same
        case ShowConnections(replyTo) =>
          replyTo ! ConnectionsList(connections)
          Behaviors.same
        case AddRule(newRule) =>
          addRule(newRule)
          Behaviors.same
      }
    }
  }

  /**
   * 新しいファイアウォールルールを追加する
   * @param newRule 新しいファイアウォールルール
   */
  def addRule(newRule: FirewallRule): Unit = {
    firewallRules += newRule
    TraceLogger.info(name, "added new rule!")
  }

  /**
   * ファイアウォールルールでdenyに指定されているかをチェックする
   * @param d ルールと照らし合わせるデータグラム
   * @return true  denyに指定されている
   * @return false denyに指定されていない
   */
  def checkDenyDatagram(d: Datagram): Boolean = {
    val matchDatagram = FirewallRule("deny",
      d.srcAddress,
      d.srcPort,
      d.dstAddress,
      d.dstPort)
    TraceLogger.info(name, s"matchDatagram: $matchDatagram" , d)
    firewallRules.find(check => check == matchDatagram) match {
      case Some(check) => { TraceLogger.info(name, "deny!", d); true }
      case None => false
    }
  }

  /**
   *  自分宛のデータグラムならば受け取り，アプリケーションがあればそこに送る
   *  自分宛では無くルーティング可能なら該当ネットワークにデータグラムを転送
   *  ただしファイアウォールルールによって転送するか破棄するかを決める
   *  @param d 受け取るデータグラム
   */
  override def networkResponse(d: Datagram): Unit = {
    val destAddress: InetAddress = d.dstAddress // 行き先アドレス

    if (!checkDenyDatagram(d)) {
      if (connections.filter(_.address == destAddress).nonEmpty) {
        // 設定されている接続のうちひとつでも行き先アドレスのものがあったら
        receiveDatagram(d) // データグラムを受け取る
      } else {
        TraceLogger.info(name, "NetworkNode has to deliver a datagram", d)
        // 行き先が同じネットワークに接続されているものがあればルーティング
        // する必要がないので，直接送信する
        connections.find(con => { con.address == d.dstAddress })
        match {
          case Some(con) => (con.network) ! d
          case None => deliverDatagram(d)
        }
      }
    } else { TraceLogger.info(name, "Packet is denied!", d) }
  }

}
