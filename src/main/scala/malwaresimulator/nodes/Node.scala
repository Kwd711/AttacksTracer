package malwaresimulator.nodes

import scala.collection.mutable.ListBuffer
import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.{ActorRef, Behavior}
import malwaresimulator.engine.applications.{ApplicationNode, Malware, WebBrowserApp, WebServerApp}
import malwaresimulator.{Connection, MalwareSimulatorSupervisor, Network}
import malwaresimulator.Network.NetworkCommand
import malwaresimulator.engine.core.{Command, Datagram, InetAddress, Protocol}
import malwaresimulator.NodeManager._
import malwaresimulator.engine.Firewall.FirewallCommand

object Node {
  trait NodeCommand
  final case class SocketOpen(actor: ActorRef[ApplicationCommand]) extends NodeCommand
  final case class OpenedSocket(socket: Socket) extends ApplicationCommand
  final case class Bind(s: Socket, address: InetAddress, port: Int) extends NodeCommand
  final case class SendTo(s: Socket, data: Protocol, dstAddress: InetAddress, dstPort: Int) extends NodeCommand
  final case class RecvFrom(s: Socket, data: Protocol, option: Any, srcAddress: InetAddress, srcPort: Int) extends ApplicationCommand
  final case class MakeConnection(address: InetAddress, netmask: Int, net: ActorRef[NetworkCommand]) extends NodeCommand with FirewallCommand
  final case class ShowConnections(replyTo: ActorRef[ApplicationCommand]) extends NodeCommand with FirewallCommand
  final case class ConnectionsList(conList: ListBuffer[Connection]) extends ApplicationCommand

  trait ExecutableNodeCommand extends NodeCommand
//  final case class SetApplication[A <: ApplicationNode](app: A, name: String) extends ExecutableNodeCommand
  final case class SetWebServer(id: Int, name: String, actorRef: ActorRef[ApplicationCommand]) extends ExecutableNodeCommand
  final case class SetWebBrowser(id: Int, name: String, actorRef: ActorRef[ApplicationCommand]) extends ExecutableNodeCommand
  final case class ApplicationRef(ref: ActorRef[ApplicationCommand]) extends NodeCommand
  final case class GetApplications(replyTo: ActorRef[AnyRef]) extends ExecutableNodeCommand
  final case class Applications(applications: ListBuffer[ActorRef[ApplicationCommand]]) extends NodeManagerCommand
  final case class Infect(name: String, ccServer: InetAddress) extends NodeCommand

  trait RoutingNodeCommand extends NodeCommand
  final case class GetRoutingTable(replyTo: ActorRef[Command]) extends RoutingNodeCommand
  final case class RoutingTable(rtable: RoutingTable) extends RoutingNodeCommand
  final case class AddRoute(dst: InetAddress, gw: InetAddress, net: Network) extends RoutingNodeCommand

  trait ApplicationCommand extends NodeCommand
  final case class SetNode(nodeRef: ActorRef[NodeCommand]) extends ApplicationCommand
  final case class SendRequest(dstAddress: InetAddress) extends ApplicationCommand
  final case class ResultSendRequest(result: String) extends NodeCommand


  def apply(id: Int, name: String, address: InetAddress): Behavior[NodeCommand] = {
    println(s"[INFO] Node($name) is started")
    new Node(id, name, address).receive()
  }
}

class Node(val id: Int, val name: String, var address: InetAddress) extends ExecutableNode with RoutingNode {
  import Node._

  def receive(): Behavior[NodeCommand] = {
    Behaviors.receive{ (context, message) =>
      message match {
        case d: Datagram =>
          networkResponse(d)
          Behaviors.same
        case MakeConnection(address, netmask, net) =>
          makeConnection(address, netmask, net)
          Behaviors.same
        case ShowConnections(replyTo) =>
          replyTo ! ConnectionsList(connections)
          Behaviors.same
        case SetWebServer(id, name, actorRef) =>
          setApplication(id, name)
          Behaviors.same
        case SetWebBrowser(id, name, actorRef) =>
//          val ref = context.spawn(WebBrowserApp(context.self, operator), name)
          setApplication(id, name)
          Behaviors.same
        case GetApplications(replyTo) =>
          println(s"[INFO] Node($name) received a GetApplicaitons message.")
          replyTo ! malwaresimulator.proto.Node(id, name, address.toString, getApplications())
          Behaviors.same
        case SocketOpen(replyTo) =>
          val socket = sockets.open(replyTo)
          replyTo ! OpenedSocket(socket)
          Behaviors.same
        case Bind(s, address, port) =>
          sockets.bind(s, address, port)
          Behaviors.same
        case SendTo(s, data, dstAddress, dstPort) =>
          sockets.sendto(s, data, dstAddress, dstPort)
          Behaviors.same
        case Infect(malwareName, ccServer) =>
          val ref = context.spawn(Malware(malwareName, context.self, ccServer), malwareName)
          infection(malwareName, ref)
          val socket = sockets.open(ref)
          ref ! OpenedSocket(socket)
          Behaviors.same
      }
    }
  }
}
