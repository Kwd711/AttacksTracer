package malwaresimulator.nodes

import akka.actor.typed.ActorRef
import akka.actor.typed.scaladsl.ActorContext
import malwaresimulator.Network.NetworkCommand
import malwaresimulator.engine.core.{Command, Datagram, InetAddress, Protocol}
import malwaresimulator.nodes.Node.{ApplicationCommand, NodeCommand}
import malwaresimulator.{Connection, Network, NodeManager}

import scala.collection.mutable.ListBuffer

///**
// * ネットワーク接続を持つノード
// */
trait NetworkNode {
  final case class SetAddress(address: InetAddress) extends Command
  final case class GetAddress(replyTo: ActorRef[Command]) extends Command
  final case class ReturnAddress(address: InetAddress) extends Command

  val sockets = new Sockets
  var connections: ListBuffer[Connection] = ListBuffer.empty
//  var address: InetAddress
  private var fileList: ListBuffer[String] = ListBuffer() // 重要データ（元の型はFileクラス）
  var responses: ListBuffer[(Datagram) => Unit] = ListBuffer.empty

  responses += networkResponse

  /**
   * アドレスをセットする
   * @param address アドレス
   */
//  def setAddress(address: InetAddress): Unit = { this.address = address }

  /**
   * アドレスを取得する
   * @return アドレス
   */
//  def getAddress(): InetAddress = { this.address }

  /**
   *  自分宛のデータグラムならば受け取り，アプリケーションがあればそこに送る
   *  自分宛では無くルーティング可能なら該当ネットワークにデータグラムを転送
   *  @param d 受け取るデータグラム
   */
  protected def networkResponse(d: Datagram): Unit = {
    val dstAddress: InetAddress = d.dstAddress

    if (connections.filter(_.address == dstAddress).nonEmpty ) {
      // 設定されている接続のうち一つでも行き先アドレスのものが会ったら
      receiveDatagram(d)  // データグラムを受け取る　
    } else {
      println(this, "Deliver internal", d)
      // 行き先が同じネットワークに接続されているものがあればルーティング
      // する必要がないので，直接送信する
      connections.find(con => {con.address == d.dstAddress})
      match {
        case Some(con) => (con.network) ! d
        case None => deliverDatagram(d)
      }
    }
  }

  /**
   *  自分宛ではないデータグラムについての処理．
   *  （RoutingNode でオーバーライドされてる）
   *  @param d 自分宛ではないデータグラム
   */
  protected def deliverDatagram(d: Datagram): Unit = {
    /* TODO: routing */
//    TraceLogger.info(this, "Deliver network", d)
    connections.foreach(con => { con.network ! d })
  }

  /**
   *  自分宛のデータグラムを受け取って処理
   *  @param d 自分宛のデータグラム
   *  TODO: Override this method
   */
  protected def receiveDatagram(d: Datagram): Unit = {
//    TraceLogger.info(this, "Received", d)
  }

  /**
   *  ネットワークに結びついたアドレスを返す
   *  @param network 指定するネットワーク
   *  @return 　　　　ネットワークに結びついたアドレス
   */
  def getAddressBindedNetwork(network: Network): InetAddress = {
    val con = connections.find(_.network == network)
    con match {
      case Some(s) => s.address
      case None    => InetAddress.Default
    }
  }

  /**
   *  接続を作成
   *  @param connection
   */
  def makeConnection(connection: Connection): Unit = {
    connections += connection
  }

  /**
   *  アドレスとネットワークを指定して接続を作成
   *  @param address 自ノードに設定するアドレス
   *  @param net  繋がる先のネットワーク
   */
  def makeConnection(address: InetAddress, netmask: Int, net: ActorRef[NetworkCommand]): Unit = {
    connections += Connection(address, netmask, net)
  }

  /**
   *  Connection をすべて表示
   */
  def displayAllConnections(): Unit = {
    connections.foreach { conn =>
      println(this + " connects to " + conn)
    }
  }

  class Sockets {
    var sockets: ListBuffer[Socket] = ListBuffer.empty

    def open(actor: ActorRef[ApplicationCommand]): Socket = {
      val s = new Socket(actor)
      sockets += s
      s
    }

    def bind(s: Socket, address: InetAddress, port: Int): Unit = {
      select(address, port) match {
        case Some(s) => println("[ERR] address already in use.")
        case None => {
          s.localAddress = address
          s.localPort = port
        }
      }
    }

    def select(localAddress: InetAddress, localPort: Int): Option[Socket] = {
      for (s <- sockets) {
        if ((s.localAddress == InetAddress.Default || s.localAddress == localAddress) && s.localPort == localPort) {
          return Some(s)
        }
      }
      None
    }


    def sendto(s: Socket, data: Protocol, dstAddress: InetAddress, dstPort: Int): Unit = {
      if (s.localAddress == InetAddress.Default) {
        s.localAddress = getAddress()
      }
      if (s.localPort == 0) {
        (49152 to 65535).find(p => select(s.localAddress, p) == None) match {
          case Some(p) => s.localPort = p
          case None => {
            println("[ERR] failed to dynamic assign local port.")
            return
          }
        }
      }
      connections.find(con => dstAddress.isSameNetwork(con.address, con.netmask)) match {
        case Some(con) => con.network ! data.datagram(s.localAddress, s.localPort, dstAddress, dstPort)
        case None => {
          println(s"[ERR] Network not found. [dstAddress=${dstAddress}]")
        }
      }
    }
  }
}

class Socket(val actor: ActorRef[ApplicationCommand]) {
  var localAddress: InetAddress = InetAddress.Default
  var localPort: Int = 0
}
